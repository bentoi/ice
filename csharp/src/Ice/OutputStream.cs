//
// Copyright (c) ZeroC, Inc. All rights reserved.
//

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;

namespace ZeroC.Ice
{
    /// <summary>All mapped structs generated by the Slice compiler implement IStreamableStruct.</summary>
    public interface IStreamableStruct
    {
        public void IceWrite(OutputStream ostr);
    }

    /// <summary>A delegate that writes a value to an output stream.</summary>
    /// <typeparam name="T">The type of the value to write.</typeparam>
    /// <param name="ostr">The output stream to write to.</param>
    /// <param name="value">The value to write to the stream.</param>
    public delegate void OutputStreamWriter<in T>(OutputStream ostr, T value);

    /// <summary>A delegate that writes a value passed as in-reference to an output stream. This value is typically an
    /// instance of a mapped Slice struct, or the parameters or return value of an operation.</summary>
    /// <typeparam name="T">The type of the value to write (a struct).</typeparam>
    /// <param name="ostr">The output stream to write to.</param>
    /// <param name="value">The value to write to the stream.</param>
    public delegate void OutputStreamStructWriter<T>(OutputStream ostr, in T value) where T : struct;

    /// <summary>Writes data into a byte buffer using the Ice encoding.</summary>
    public sealed partial class OutputStream
    {
        /// <summary>Represents a position in the OutputStream's buffer. This position consists of the index of the
        /// segment in the list and the offset into the segment.</summary>
        internal struct Position
        {
            /// <summary>Creates a new position from the segment and offset values.</summary>
            /// <param name="segment">The zero based index of the segment.</param>
            /// <param name="offset">The offset into the segment.</param>
            internal Position(int segment, int offset)
            {
                Segment = segment;
                Offset = offset;
            }

            /// <summary>The zero based index of the segment.</summary>
            internal int Segment;
            /// <summary>The offset into the segment.</summary>
            internal int Offset;
        }

        //
        // Cached OutputStreamWriter static objects used by the generated code
        //

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<bool> IceWriterFromBool =
            (ostr, value) => ostr.WriteBool(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<bool[]> IceWriterFromBoolArray =
            (ostr, value) => ostr.WriteFixedSizeNumericArray(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ReadOnlyMemory<bool>> IceWriterFromBoolSequence =
            (ostr, value) => ostr.WriteFixedSizeNumericSequence(value.Span);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<byte> IceWriterFromByte =
            (ostr, value) => ostr.WriteByte(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<byte[]> IceWriterFromByteArray =
            (ostr, value) => ostr.WriteFixedSizeNumericArray(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ReadOnlyMemory<byte>> IceWriterFromByteSequence =
            (ostr, value) => ostr.WriteFixedSizeNumericSequence(value.Span);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<double> IceWriterFromDouble =
            (ostr, value) => ostr.WriteDouble(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<double[]> IceWriterFromDoubleArray =
            (ostr, value) => ostr.WriteFixedSizeNumericArray(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ReadOnlyMemory<double>> IceWriterFromDoubleSequence =
            (ostr, value) => ostr.WriteFixedSizeNumericSequence(value.Span);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<float> IceWriterFromFloat =
            (ostr, value) => ostr.WriteFloat(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<float[]> IceWriterFromFloatArray =
            (ostr, value) => ostr.WriteFixedSizeNumericArray(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ReadOnlyMemory<float>> IceWriterFromFloatSequence =
            (ostr, value) => ostr.WriteFixedSizeNumericSequence(value.Span);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<int> IceWriterFromInt =
            (ostr, value) => ostr.WriteInt(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<int[]> IceWriterFromIntArray =
            (ostr, value) => ostr.WriteFixedSizeNumericArray(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ReadOnlyMemory<int>> IceWriterFromIntSequence =
            (ostr, value) => ostr.WriteFixedSizeNumericSequence(value.Span);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<long> IceWriterFromLong =
            (ostr, value) => ostr.WriteLong(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<long[]> IceWriterFromLongArray =
            (ostr, value) => ostr.WriteFixedSizeNumericArray(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ReadOnlyMemory<long>> IceWriterFromLongSequence =
            (ostr, value) => ostr.WriteFixedSizeNumericSequence(value.Span);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<short> IceWriterFromShort =
            (ostr, value) => ostr.WriteShort(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<short[]> IceWriterFromShortArray =
            (ostr, value) => ostr.WriteFixedSizeNumericArray(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ReadOnlyMemory<short>> IceWriterFromShortSequence =
            (ostr, value) => ostr.WriteFixedSizeNumericSequence(value.Span);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<string> IceWriterFromString =
            (ostr, value) => ostr.WriteString(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<uint> IceWriterFromUInt =
            (ostr, value) => ostr.WriteUInt(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<uint[]> IceWriterFromUIntArray =
            (ostr, value) => ostr.WriteFixedSizeNumericArray(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ReadOnlyMemory<uint>> IceWriterFromUIntSequence =
            (ostr, value) => ostr.WriteFixedSizeNumericSequence(value.Span);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ulong> IceWriterFromULong =
            (ostr, value) => ostr.WriteULong(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ulong[]> IceWriterFromULongArray =
            (ostr, value) => ostr.WriteFixedSizeNumericArray(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ReadOnlyMemory<ulong>> IceWriterFromULongSequence =
            (ostr, value) => ostr.WriteFixedSizeNumericSequence(value.Span);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ushort> IceWriterFromUShort =
            (ostr, value) => ostr.WriteUShort(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ushort[]> IceWriterFromUShortArray =
            (ostr, value) => ostr.WriteFixedSizeNumericArray(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ReadOnlyMemory<ushort>> IceWriterFromUShortSequence =
            (ostr, value) => ostr.WriteFixedSizeNumericSequence(value.Span);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<int> IceWriterFromVarInt =
            (ostr, value) => ostr.WriteVarInt(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<long> IceWriterFromVarLong =
            (ostr, value) => ostr.WriteVarLong(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<uint> IceWriterFromVarUInt =
            (ostr, value) => ostr.WriteVarUInt(value);

        [EditorBrowsable(EditorBrowsableState.Never)]
        public static readonly OutputStreamWriter<ulong> IceWriterFromVarULong =
            (ostr, value) => ostr.WriteVarULong(value);

        /// <summary>The encoding used when writing to this stream.</summary>
        /// <value>The encoding.</value>
        public Encoding Encoding { get; private set; }

        /// <summary>Determines the current size of the stream. This corresponds to the number of bytes already written
        /// to the stream.</summary>
        /// <value>The current size.</value>
        internal int Size { get; private set; }

        // Gets the position for the next write operation.
        internal Position Tail => _tail;

        private const int DefaultSegmentSize = 256;

        // The number of bytes we use by default when writing a size on a fixed number of byte with the 2.0 encoding.
        private const int DefaultSizeLength = 4;

        private static readonly System.Text.UTF8Encoding _utf8 = new System.Text.UTF8Encoding(false, true);

        private bool InEncapsulation => _startPos != null;

        private bool OldEncoding => Encoding == Encoding.V1_1;

        // The number of bytes that the stream can hold.
        private int _capacity;

        // Data for the class or exception instance that is currently getting marshaled.
        private InstanceData? _current;

        // The segment currently used by write operations, this is usually the last segment of the segment list but it
        // can occasionally be one before last after expanding the list. The tail Position always points to this
        // segment, and the tail offset indicates how much of the segment has been used.
        private ArraySegment<byte> _currentSegment;

        // The current class/exception format, can be either Compact or Sliced.
        private readonly FormatType _format;

        // Map of class instance to instance ID, where the instance IDs start at 2.
        // When writing a top-level encapsulation:
        //  - Instance ID = 0 means null.
        //  - Instance ID = 1 means the instance is encoded inline afterwards.
        //  - Instance ID > 1 means a reference to a previously encoded instance, found in this map.
        private Dictionary<AnyClass, int>? _instanceMap;

        // The encoding used to write the encapsulation header itself.
        private readonly Encoding _mainEncoding;

        // All segments before the tail segment are fully used.
        private readonly List<ArraySegment<byte>> _segmentList;

        // The start of an encapsulation. When set, we are writing to a top-level encapsulation.
        private readonly Position? _startPos;

        // The position for the next write operation.
        private Position _tail;

        // Map of type ID string to type ID index.
        // When writing into a top-level encapsulation, we assign a type ID index (starting with 1) to each type ID we
        // write, in order.
        private Dictionary<string, int>? _typeIdMap;

        //
        // Write methods for basic types
        //

        /// <summary>Writes a boolean to the stream.</summary>
        /// <param name="v">The boolean to write to the stream.</param>
        public void WriteBool(bool v) => WriteByte(v ? (byte)1 : (byte)0);

        /// <summary>Writes a byte to the stream.</summary>
        /// <param name="v">The byte to write.</param>
        public void WriteByte(byte v)
        {
            Expand(1);
            int offset = _tail.Offset;
            if (offset < _currentSegment.Count)
            {
                _currentSegment[offset] = v;
                _tail.Offset++;
            }
            else
            {
                _currentSegment = _segmentList[++_tail.Segment];
                _currentSegment[0] = v;
                _tail.Offset = 1;
            }
            Size++;
        }

        /// <summary>Writes a double to the stream.</summary>
        /// <param name="v">The double to write to the stream.</param>
        public void WriteDouble(double v) => WriteFixedSizeNumeric(v);

        /// <summary>Writes a float to the stream.</summary>
        /// <param name="v">The float to write to the stream.</param>
        public void WriteFloat(float v) => WriteFixedSizeNumeric(v);

        /// <summary>Writes an int to the stream.</summary>
        /// <param name="v">The int to write to the stream.</param>
        public void WriteInt(int v) => WriteFixedSizeNumeric(v);

        /// <summary>Writes a long to the stream.</summary>
        /// <param name="v">The long to write to the stream.</param>
        public void WriteLong(long v) => WriteFixedSizeNumeric(v);

        /// <summary>Writes a short to the stream.</summary>
        /// <param name="v">The short to write to the stream.</param>
        public void WriteShort(short v) => WriteFixedSizeNumeric(v);

        /// <summary>Writes a string to the stream.</summary>
        /// <param name="v">The string to write to the stream.</param>
        public void WriteString(string v)
        {
            if (v.Length == 0)
            {
                WriteSize(0);
            }
            else if (v.Length <= 100)
            {
                Span<byte> data = stackalloc byte[_utf8.GetMaxByteCount(v.Length)];
                int written = _utf8.GetBytes(v, data);
                WriteSize(written);
                WriteByteSpan(data.Slice(0, written));
            }
            else
            {
                byte[] data = _utf8.GetBytes(v);
                WriteSize(data.Length);
                WriteByteSpan(data.AsSpan());
            }
        }

        /// <summary>Writes a uint to the stream.</summary>
        /// <param name="v">The uint to write to the stream.</param>
        public void WriteUInt(uint v) => WriteFixedSizeNumeric(v);

        /// <summary>Writes a ulong to the stream.</summary>
        /// <param name="v">The ulong to write to the stream.</param>
        public void WriteULong(ulong v) => WriteFixedSizeNumeric(v);

        /// <summary>Writes a ushort to the stream.</summary>
        /// <param name="v">The ushort to write to the stream.</param>
        public void WriteUShort(ushort v) => WriteFixedSizeNumeric(v);

        /// <summary>Writes an int to stream, using Ice's variable-length integer encoding.</summary>
        /// <param name="v">The int to write to the stream.</param>
        public void WriteVarInt(int v) => WriteVarLong(v);

        /// <summary>Writes a long to stream, using Ice's variable-length integer encoding, with the minimum number of
        /// bytes required by the encoding.</summary>
        /// <param name="v">The long to write to the stream. It must be in the range [-2^61..2^61 - 1].</param>
        public void WriteVarLong(long v)
        {
            if (v < EncodingDefinitions.VarLongMinValue || v > EncodingDefinitions.VarLongMaxValue)
            {
                throw new ArgumentOutOfRangeException($"varlong value `{v}' is out of range", nameof(v));
            }

            if (OldEncoding)
            {
                WriteLong(v);
            }
            else
            {
                v <<= 2;
                int encodedLength = v switch
                {
                    long b when b >= sbyte.MinValue && b <= sbyte.MaxValue => 0,
                    long s when s >= short.MinValue && s <= short.MaxValue => 1,
                    long i when i >= int.MinValue && i <= int.MaxValue => 2,
                    _ => 3
                };

                v |= (uint)encodedLength;
                Span<byte> data = stackalloc byte[sizeof(long)];
                MemoryMarshal.Write(data, ref v);
                WriteByteSpan(data.Slice(0, 1 << encodedLength));
            }
        }

        /// <summary>Writes a uint to stream, using Ice's variable-length integer encoding.</summary>
        /// <param name="v">The uint to write to the stream.</param>
        public void WriteVarUInt(uint v) => WriteVarULong(v);

        /// <summary>Writes a ulong to stream, using Ice's variable-length integer encoding, with the minimum number of
        /// bytes required by the encoding.</summary>
        /// <param name="v">The ulong to write to the stream. It must be in the range [0..2^62 - 1].</param>
        public void WriteVarULong(ulong v)
        {
            if (v > EncodingDefinitions.VarULongMaxValue)
            {
                throw new ArgumentOutOfRangeException($"varulong value `{v}' is out of range", nameof(v));
            }

            if (OldEncoding)
            {
                WriteULong(v);
            }
            else
            {
                v <<= 2;
                int encodedLength = v switch
                {
                    ulong b when b <= byte.MaxValue => 0,
                    ulong s when s <= ushort.MaxValue => 1,
                    ulong i when i <= uint.MaxValue => 2,
                    _ => 3
                };

                v |= (uint)encodedLength;
                Span<byte> data = stackalloc byte[sizeof(ulong)];
                MemoryMarshal.Write(data, ref v);
                WriteByteSpan(data.Slice(0, 1 << encodedLength));
            }
        }

        //
        // Write methods for constructed types except class and exception
        //

        /// <summary>Writes a dictionary to the stream.</summary>
        /// <param name="v">The dictionary to write.</param>
        /// <param name="keyWriter">The delegate that writes each key to the stream.</param>
        /// <param name="valueWriter">The delegate that writes each value to the stream.</param>
        public void WriteDictionary<TKey, TValue>(IReadOnlyDictionary<TKey, TValue> v,
                                                  OutputStreamWriter<TKey> keyWriter,
                                                  OutputStreamWriter<TValue> valueWriter) where TKey : notnull
        {
            WriteSize(v.Count);
            foreach ((TKey key, TValue value) in v)
            {
                keyWriter(this, key);
                valueWriter(this, value);
            }
        }

        /// <summary>Writes a dictionary to the stream. The dictionary's key is a mapped Slice struct.</summary>
        /// <param name="v">The dictionary to write.</param>
        /// <param name="valueWriter">The delegate that writes each value to the stream.</param>
        public void WriteDictionary<TKey, TValue>(IReadOnlyDictionary<TKey, TValue> v,
                                                  OutputStreamWriter<TValue> valueWriter)
            where TKey : struct, IStreamableStruct
        {
            WriteSize(v.Count);
            foreach ((TKey key, TValue value) in v)
            {
                key.IceWrite(this);
                valueWriter(this, value);
            }
        }

        /// <summary>Writes a dictionary to the stream. The dictionary's value is a mapped Slice struct.</summary>
        /// <param name="v">The dictionary to write.</param>
        /// <param name="keyWriter">The delegate that writes each key to the stream.</param>
        public void WriteDictionary<TKey, TValue>(IReadOnlyDictionary<TKey, TValue> v,
                                                  OutputStreamWriter<TKey> keyWriter)
            where TKey : notnull
            where TValue : struct, IStreamableStruct
        {
            WriteSize(v.Count);
            foreach ((TKey key, TValue value) in v)
            {
                keyWriter(this, key);
                value.IceWrite(this);
            }
        }

        /// <summary>Writes a dictionary to the stream. Both the dictionary's key and value are mapped Slice structs.
        /// </summary>
        /// <param name="v">The dictionary to write.</param>
        public void WriteDictionary<TKey, TValue>(IReadOnlyDictionary<TKey, TValue> v)
            where TKey : struct, IStreamableStruct
            where TValue : struct, IStreamableStruct
        {
            WriteSize(v.Count);
            foreach ((TKey key, TValue value) in v)
            {
                key.IceWrite(this);
                value.IceWrite(this);
            }
        }

        /// <summary>Writes an enumerator to the stream.</summary>
        /// <param name="v">The enumerator's int value.</param>
        public void WriteEnum(int v) => WriteSize(v);

        /// <summary>Writes an array of fixed-size numeric type, such as int and long, to the stream.</summary>
        /// <param name="v">The array of numeric types.</param>
        public void WriteFixedSizeNumericArray<T>(T[] v) where T : struct =>
            WriteFixedSizeNumericSequence(new ReadOnlySpan<T>(v));

        /// <summary>Writes a sequence of fixed-size numeric type, such as int and long, to the stream.</summary>
        /// <param name="v">The sequence of numeric types represented by a ReadOnlySpan.</param>
        // This method works because (as long as) there is no padding in the memory representation of the
        // ReadOnlySpan.
        public void WriteFixedSizeNumericSequence<T>(ReadOnlySpan<T> v) where T : struct
        {
            WriteSize(v.Length);
            WriteByteSpan(MemoryMarshal.AsBytes(v));
        }

        /// <summary>Writes a proxy to the stream.</summary>
        /// <param name="v">The proxy to write.</param>
        public void WriteProxy<T>(T? v) where T : class, IObjectPrx
        {
            if (v != null)
            {
                v.IceWrite(this);
            }
            else
            {
                Identity.Empty.IceWrite(this);
            }
        }

        /// <summary>Writes a sequence to the stream.</summary>
        /// <param name="v">The sequence to write.</param>
        /// <param name="writer">The delegate that writes each element to the stream.</param>
        public void WriteSequence<T>(IEnumerable<T> v, OutputStreamWriter<T> writer)
        {
            WriteSize(v.Count()); // potentially slow Linq Count()
            foreach (T item in v)
            {
                writer(this, item);
            }
        }

        /// <summary>Writes a sequence to the stream. Elements of the sequence are mapped Slice structs.</summary>
        /// <param name="v">The sequence to write.</param>
        public void WriteSequence<T>(IEnumerable<T> v)
            where T : struct, IStreamableStruct
        {
            WriteSize(v.Count()); // potentially slow Linq Count()
            foreach (T item in v)
            {
                item.IceWrite(this);
            }
        }

        /// <summary>Writes a serializable object to the stream.</summary>
        /// <param name="o">The serializable object to write.</param>
        public void WriteSerializable(object o)
        {
            var w = new StreamWrapper(this);
            IFormatter f = new BinaryFormatter();
            f.Serialize(w, o);
            w.Close();
        }

        /// <summary>Writes a mapped Slice struct to the stream.</summary>
        /// <param name="v">The struct instance to write.</param>
        public void WriteStruct<T>(in T v) where T : struct, IStreamableStruct => v.IceWrite(this);

        //
        // Write methods for tagged basic types
        //

        /// <summary>Writes a tagged boolean to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The boolean to write to the stream.</param>
        public void WriteTaggedBool(int tag, bool? v)
        {
            if (v is bool value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.F1);
                WriteBool(value);
            }
        }

        /// <summary>Writes a tagged byte to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The byte to write to the stream.</param>
        public void WriteTaggedByte(int tag, byte? v)
        {
            if (v is byte value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.F1);
                WriteByte(value);
            }
        }

        /// <summary>Writes a tagged double to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The double to write to the stream.</param>
        public void WriteTaggedDouble(int tag, double? v)
        {
            if (v is double value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.F8);
                WriteDouble(value);
            }
        }

        /// <summary>Writes a tagged float to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The float to write to the stream.</param>
        public void WriteTaggedFloat(int tag, float? v)
        {
            if (v is float value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.F4);
                WriteFloat(value);
            }
        }

        /// <summary>Writes a tagged int to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The int to write to the stream.</param>
        public void WriteTaggedInt(int tag, int? v)
        {
            if (v is int value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.F4);
                WriteInt(value);
            }
        }

        /// <summary>Writes a tagged long to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The long to write to the stream.</param>
        public void WriteTaggedLong(int tag, long? v)
        {
            if (v is long value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.F8);
                WriteLong(value);
            }
        }

        /// <summary>Writes a tagged short to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The short to write to the stream.</param>
        public void WriteTaggedShort(int tag, short? v)
        {
            if (v is short value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.F2);
                WriteShort(value);
            }
        }

        /// <summary>Writes a tagged string to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The string to write to the stream.</param>
        public void WriteTaggedString(int tag, string? v)
        {
            if (v is string value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.VSize);
                WriteString(value);
            }
        }

        //
        // Write methods for tagged constructed types except class
        //

        /// <summary>Writes a tagged dictionary with fixed-size entries to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The dictionary to write.</param>
        /// <param name="entrySize">The size of each entry (key + value), in bytes.</param>
        /// <param name="keyWriter">The delegate that writes each key to the stream.</param>
        /// <param name="valueWriter">The delegate that writes each value to the stream.</param>
        public void WriteTaggedDictionary<TKey, TValue>(int tag,
                                                        IReadOnlyDictionary<TKey, TValue>? v,
                                                        int entrySize,
                                                        OutputStreamWriter<TKey> keyWriter,
                                                        OutputStreamWriter<TValue> valueWriter)
            where TKey : notnull
        {
            Debug.Assert(entrySize > 1);
            if (v is IReadOnlyDictionary<TKey, TValue> dict)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.VSize);
                int count = dict.Count;
                WriteSize(count == 0 ? 1 : (count * entrySize) + GetSizeLength(count));
                WriteDictionary(dict, keyWriter, valueWriter);
            }
        }

        /// <summary>Writes a tagged dictionary with fixed-size entries to the stream. The dictionary's key is a mapped
        /// Slice struct.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The dictionary to write.</param>
        /// <param name="entrySize">The size of each entry (key + value), in bytes.</param>
        /// <param name="valueWriter">The delegate that writes each value to the stream.</param>
        public void WriteTaggedDictionary<TKey, TValue>(int tag,
                                                        IReadOnlyDictionary<TKey, TValue>? v,
                                                        int entrySize,
                                                        OutputStreamWriter<TValue> valueWriter)
            where TKey : struct, IStreamableStruct
        {
            Debug.Assert(entrySize > 1);
            if (v is IReadOnlyDictionary<TKey, TValue> dict)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.VSize);
                int count = dict.Count;
                WriteSize(count == 0 ? 1 : (count * entrySize) + GetSizeLength(count));
                WriteDictionary(dict, valueWriter);
            }
        }

        /// <summary>Writes a tagged dictionary with fixed-size entries to the stream. The dictionary's value is a
        /// mapped Slice struct.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The dictionary to write.</param>
        /// <param name="entrySize">The size of each entry (key + value), in bytes.</param>
        /// <param name="keyWriter">The delegate that writes each key to the stream.</param>
        public void WriteTaggedDictionary<TKey, TValue>(int tag,
                                                        IReadOnlyDictionary<TKey, TValue>? v,
                                                        int entrySize,
                                                        OutputStreamWriter<TKey> keyWriter)
            where TKey : notnull
            where TValue : struct, IStreamableStruct
        {
            Debug.Assert(entrySize > 1);
            if (v is IReadOnlyDictionary<TKey, TValue> dict)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.VSize);
                int count = dict.Count;
                WriteSize(count == 0 ? 1 : (count * entrySize) + GetSizeLength(count));
                WriteDictionary(dict, keyWriter);
            }
        }

        /// <summary>Writes a tagged dictionary with fixed-size entries to the stream. Both the dictionary's key and
        /// value are mapped Slice structs.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The dictionary to write.</param>
        /// <param name="entrySize">The size of each entry (key + value), in bytes.</param>
        public void WriteTaggedDictionary<TKey, TValue>(int tag,
                                                        IReadOnlyDictionary<TKey, TValue>? v,
                                                        int entrySize)
            where TKey : struct, IStreamableStruct
            where TValue : struct, IStreamableStruct
        {
            Debug.Assert(entrySize > 1);
            if (v is IReadOnlyDictionary<TKey, TValue> dict)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.VSize);
                int count = dict.Count;
                WriteSize(count == 0 ? 1 : (count * entrySize) + GetSizeLength(count));
                WriteDictionary(dict);
            }
        }

        /// <summary>Writes a tagged dictionary with variable-size elements to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The dictionary to write.</param>
        /// <param name="keyWriter">The delegate that writes each key to the stream.</param>
        /// <param name="valueWriter">The delegate that writes each value to the stream.</param>
        public void WriteTaggedDictionary<TKey, TValue>(int tag,
                                                        IReadOnlyDictionary<TKey, TValue>? v,
                                                        OutputStreamWriter<TKey> keyWriter,
                                                        OutputStreamWriter<TValue> valueWriter)
            where TKey : notnull
        {
            if (v is IReadOnlyDictionary<TKey, TValue> dict)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.FSize);
                Position pos = StartFixedLengthSize();
                WriteDictionary(dict, keyWriter, valueWriter);
                EndFixedLengthSize(pos);
            }
        }

        /// <summary>Writes a tagged dictionary with variable-size elements to the stream. The dictionary's key is
        /// a mapped Slice struct.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The dictionary to write.</param>
        /// <param name="valueWriter">The delegate that writes each value to the stream.</param>
        public void WriteTaggedDictionary<TKey, TValue>(int tag,
                                                        IReadOnlyDictionary<TKey, TValue>? v,
                                                        OutputStreamWriter<TValue> valueWriter)
            where TKey : struct, IStreamableStruct
        {
            if (v is IReadOnlyDictionary<TKey, TValue> dict)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.FSize);
                Position pos = StartFixedLengthSize();
                WriteDictionary(dict, valueWriter);
                EndFixedLengthSize(pos);
            }
        }

        /// <summary>Writes a tagged dictionary with variable-size elements to the stream. The dictionary's value is a
        /// mapped Slice struct.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The dictionary to write.</param>
        /// <param name="keyWriter">The delegate that writes each key to the stream.</param>
        public void WriteTaggedDictionary<TKey, TValue>(int tag,
                                                        IReadOnlyDictionary<TKey, TValue>? v,
                                                        OutputStreamWriter<TKey> keyWriter)
            where TKey : notnull
            where TValue : struct, IStreamableStruct
        {
            if (v is IReadOnlyDictionary<TKey, TValue> dict)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.FSize);
                Position pos = StartFixedLengthSize();
                WriteDictionary(dict, keyWriter);
                EndFixedLengthSize(pos);
            }
        }

        /// <summary>Writes a tagged dictionary with variable-size elements to the stream. Both the dictionary's key and
        /// value are mapped Slice structs.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The dictionary to write.</param>
        public void WriteTaggedDictionary<TKey, TValue>(int tag,
                                                        IReadOnlyDictionary<TKey, TValue>? v)
            where TKey : struct, IStreamableStruct
            where TValue : struct, IStreamableStruct
        {
            if (v is IReadOnlyDictionary<TKey, TValue> dict)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.FSize);
                Position pos = StartFixedLengthSize();
                WriteDictionary(dict);
                EndFixedLengthSize(pos);
            }
        }

        /// <summary>Writes a tagged enumerator to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The enumerator.</param>
        public void WriteTaggedEnum(int tag, int? v)
        {
            if (v is int value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.Size);
                WriteSize(value);
            }
        }

        /// <summary>Writes a tagged array of fixed-size numeric type to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The array to write.</param>
        public void WriteTaggedFixedSizeNumericArray<T>(int tag, T[]? v) where T : struct
            => WriteTaggedFixedSizeNumericSequence(tag, new ReadOnlySpan<T>(v));

        /// <summary>Writes a tagged sequence of fixed-size numeric type to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The sequence to write.</param>
        public void WriteTaggedFixedSizeNumericSequence<T>(int tag, ReadOnlySpan<T> v) where T : struct
        {
            // A null T[]? or List<T>? is implicitly converted into a default aka null ReadOnlyMemory<T> or
            // ReadOnlySpan<T>. Furthermore, the span of a default ReadOnlyMemory<T> is a default ReadOnlySpan<T>, which
            // is distinct from the span of an empty sequence. This is why the "v != null" below works correctly.
            if (v != null)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.VSize);
                int elementSize = Unsafe.SizeOf<T>();
                if (elementSize > 1)
                {
                    // This size is redundant and optimized out by the encoding when elementSize is 1.
                    WriteSize(v.Length == 0 ? 1 : (v.Length * elementSize) + GetSizeLength(v.Length));
                }
                WriteFixedSizeNumericSequence(v);
            }
        }

        /// <summary>Writes a tagged proxy to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The proxy to write.</param>
        public void WriteTaggedProxy(int tag, IObjectPrx? v)
        {
            if (v != null)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.FSize);
                Position pos = StartFixedLengthSize();
                WriteProxy(v);
                EndFixedLengthSize(pos);
            }
        }

        /// <summary>Writes a tagged sequence of fixed-size elements to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The sequence to write.</param>
        /// <param name="elementSize">The fixed size of each element of the sequence, in bytes.</param>
        /// <param name="writer">The delegate that writes each element to the stream.</param>
        public void WriteTaggedSequence<T>(int tag, IEnumerable<T>? v, int elementSize, OutputStreamWriter<T> writer)
        {
            Debug.Assert(elementSize > 0);
            if (v is IEnumerable<T> value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.VSize);

                int count = value.Count(); // potentially slow Linq Count()

                if (elementSize > 1)
                {
                    // First write the size in bytes, so that the reader can skip it. We optimize-out this byte size
                    // when elementSize is 1.
                    WriteSize(count == 0 ? 1 : (count * elementSize) + GetSizeLength(count));
                }
                WriteSize(count);
                foreach (T item in value)
                {
                    writer(this, item);
                }
            }
        }

        /// <summary>Writes a tagged sequence of fixed-size elements to the stream. Elements of the sequence are
        /// mapped Slice structs.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The sequence to write.</param>
        /// <param name="elementSize">The fixed size of each element of the sequence, in bytes.</param>
        public void WriteTaggedSequence<T>(int tag,
                                           IEnumerable<T>? v,
                                           int elementSize)
            where T : struct, IStreamableStruct
        {
            Debug.Assert(elementSize > 0);
            if (v is IEnumerable<T> value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.VSize);

                int count = value.Count(); // potentially slow Linq Count()

                if (elementSize > 1)
                {
                    // First write the size in bytes, so that the reader can skip it. We optimize-out this byte size
                    // when elementSize is 1.
                    WriteSize(count == 0 ? 1 : (count * elementSize) + GetSizeLength(count));
                }

                // Write the sequence "inline" instead of calling WriteSequence to avoid recomputing count.
                WriteSize(count);
                foreach (T item in value)
                {
                    item.IceWrite(this);
                }
            }
        }

        /// <summary>Writes a tagged sequence of variable-size elements to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The sequence to write.</param>
        /// <param name="writer">The delegate that writes each element to the stream.</param>
        public void WriteTaggedSequence<T>(int tag, IEnumerable<T>? v, OutputStreamWriter<T> writer)
        {
            if (v is IEnumerable<T> value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.FSize);
                Position pos = StartFixedLengthSize();
                WriteSequence(value, writer);
                EndFixedLengthSize(pos);
            }
        }

        /// <summary>Writes a tagged sequence of variable-size elements to the stream. Elements of the sequence are
        /// mapped Slice structs.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The sequence to write.</param>
        public void WriteTaggedSequence<T>(int tag, IEnumerable<T>? v)
            where T : struct, IStreamableStruct
        {
            if (v is IEnumerable<T> value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.FSize);
                Position pos = StartFixedLengthSize();
                WriteSequence(value);
                EndFixedLengthSize(pos);
            }
        }

        /// <summary>Writes a tagged serializable object to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="o">The serializable object to write.</param>
        public void WriteTaggedSerializable(int tag, object? o)
        {
            if (o != null)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.VSize);
                var w = new StreamWrapper(this);
                IFormatter f = new BinaryFormatter();
                f.Serialize(w, o);
                w.Close();
            }
        }

        /// <summary>Writes a tagged fixed-size struct to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The struct to write.</param>
        /// <param name="fixedSize">The size of the struct, in bytes.</param>
        public void WriteTaggedStruct<T>(int tag, T? v, int fixedSize) where T : struct, IStreamableStruct
        {
            if (v is T value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.VSize);
                WriteSize(fixedSize);
                value.IceWrite(this);
            }
        }

        /// <summary>Writes a tagged variable-size struct to the stream.</summary>
        /// <param name="tag">The tag.</param>
        /// <param name="v">The struct to write.</param>
        public void WriteTaggedStruct<T>(int tag, T? v) where T : struct, IStreamableStruct
        {
            if (v is T value)
            {
                WriteTaggedParamHeader(tag, EncodingDefinitions.TagFormat.FSize);
                Position pos = StartFixedLengthSize();
                value.IceWrite(this);
                EndFixedLengthSize(pos);
            }
        }

        //
        // Other methods
        //

        internal static void WriteInt(int v, Span<byte> data) => MemoryMarshal.Write(data, ref v);

        // Constructor for protocol frame header and other non-encapsulated data.
        internal OutputStream(Encoding encoding, List<ArraySegment<byte>> data, Position? startAt = null)
        {
            _mainEncoding = encoding;
            Encoding = encoding;
            Encoding.CheckSupported();
            _format = default; // not used
            _segmentList = data;
            if (_segmentList.Count == 0)
            {
                _currentSegment = ArraySegment<byte>.Empty;
                _capacity = 0;
                Size = 0;
                _tail = new Position(0, 0);
            }
            else
            {
                _tail = startAt ?? new Position(0, 0);
                _currentSegment = _segmentList[_tail.Segment];
                Size = Distance(new Position(0, 0));
                _capacity = 0;
                foreach (ArraySegment<byte> segment in _segmentList)
                {
                    _capacity += segment.Count;
                }
            }
        }

        // Constructor that starts an encapsulation.
        internal OutputStream(
            Encoding encoding,
            List<ArraySegment<byte>> data,
            Position startAt,
            Encoding payloadEncoding,
            FormatType format)
            : this(encoding, data, startAt)
        {
            _format = format;
            _startPos = _tail;
            WriteEncapsulationHeader(0, payloadEncoding); // 0 is a placeholder for the actual encapsulation size
            Encoding = payloadEncoding;
        }

        /// <summary>Finishes writing to the stream, in particular completes the current encapsulation (if any).
        /// </summary>
        /// <returns>The tail position that marks the end of the stream.</returns>
        /// TODO: The stream should not longer be used, how can we enforce it.
        internal Position Save()
        {
            _segmentList[_tail.Segment] = _segmentList[_tail.Segment].Slice(0, _tail.Offset);

            if (_startPos is Position startPos)
            {
                Encoding = _mainEncoding;
                int sizeLength = OldEncoding ? 4 : DefaultSizeLength;
                RewriteEncapsulationSize(Distance(startPos) - sizeLength, startPos);
            }
            return _tail;
        }

        /// <summary>Writes an empty encapsulation.</summary>
        internal Position WriteEmptyEncapsulation(Encoding encoding)
        {
            WriteEncapsulationHeader(size: 2, encoding, sizeLength: 1);
            _segmentList[_tail.Segment] = _segmentList[_tail.Segment].Slice(0, _tail.Offset);
            return _tail;
        }

        internal void WriteEndpoint(Endpoint endpoint)
        {
            int sizeLength = OldEncoding ? 4 : 2;

            // Encoding does not change at all in this method.

            WriteShort((short)endpoint.Type);
            if (endpoint is OpaqueEndpoint opaqueEndpoint)
            {
                // 2 is the encoding length
                WriteEncapsulationHeader(2 + opaqueEndpoint.Bytes.Length, opaqueEndpoint.Encoding, sizeLength);
                WriteByteSpan(opaqueEndpoint.Bytes.Span); // WriteByteSpan is not encoding-sensitive
            }
            else
            {
                Position startPos = _tail;
                WriteEncapsulationHeader(0, Encoding, sizeLength); // 0 is a placeholder for the size
                endpoint.IceWritePayload(this);
                RewriteEncapsulationSize(Distance(startPos) - sizeLength, startPos, sizeLength);
            }
        }

        /// <summary>Writes a facet to the stream.</summary>
        /// <param name="facet">The facet to write to the stream.</param>
        internal void WriteFacet(string facet)
        {
            // The old facet-path style used by the ice1 protocol.
            if (facet.Length == 0)
            {
                WriteSize(0);
            }
            else
            {
                WriteSize(1);
                WriteString(facet);
            }
        }

        /// <summary>Writes a size to the stream.</summary>
        /// <param name="v">The size to write.</param>
        internal void WriteSize(int v)
        {
            if (OldEncoding)
            {
                if (v < 255)
                {
                    WriteByte((byte)v);
                }
                else
                {
                    WriteByte(255);
                    WriteInt(v);
                }
            }
            else
            {
                WriteVarULong((ulong)v);
            }
        }

        private static int Distance(IList<ArraySegment<byte>> data, Position start, Position end)
        {
            // If both the start and end position are in the same array segment just
            // compute the offsets distance.
            if (start.Segment == end.Segment)
            {
                return end.Offset - start.Offset;
            }

            // If start and end position are in different segments we need to accumulate the
            // size from start offset to the end of the start segment, the size of the intermediary
            // segments, and the current offset into the last segment.
            ArraySegment<byte> segment = data[start.Segment];
            int size = segment.Count - start.Offset;
            for (int i = start.Segment + 1; i < end.Segment; ++i)
            {
                checked
                {
                    size += data[i].Count;
                }
            }
            checked
            {
                return size + end.Offset;
            }
        }

        /// <summary>Writes a size into a span of bytes using a fixed number of bytes.</summary>
        /// <param name="size">The size to write.</param>
        /// <param name="data">The destination byte buffer, which must be 1, 2 or 4 bytes long.</param>
        private static void WriteFixedLength20Size(int size, Span<byte> data)
        {
            int sizeLength = data.Length;
            Debug.Assert(sizeLength == 1 || sizeLength == 2 || sizeLength == 4);

            if (size < 0 || size > 1_073_741_823) // 2^30 -1
            {
                throw new ArgumentOutOfRangeException("size is out of range", nameof(size));
            }

            Span<byte> uintBuf = stackalloc byte[4];
            uint v = (uint)size;
            v <<= 2;

            uint encodedLength = sizeLength switch
            {
                1 => 0x00,
                2 => 0x01,
                _ => 0x02
            };
            v |= encodedLength;
            MemoryMarshal.Write(uintBuf, ref v);
            for (int i = sizeLength; i < 4; ++i)
            {
                if (uintBuf[i] != 0)
                {
                    throw new ArgumentOutOfRangeException($"size `{size}' does not fit in {sizeLength} bytes",
                        nameof(size));
                }
            }
            uintBuf.Slice(0, sizeLength).CopyTo(data);
        }

        /// <summary>Returns the distance in bytes from start position to the current position.</summary>
        /// <param name="start">The start position from where to calculate distance to current position.</param>
        /// <returns>The distance in bytes from the current position to the start position.</returns>
        private int Distance(Position start)
        {
            Debug.Assert(_tail.Segment > start.Segment ||
                        (_tail.Segment == start.Segment && _tail.Offset >= start.Offset));

            return Distance(_segmentList, start, _tail);
        }

        /// <summary>Computes the amount of data written from the start position to the current position and writes that
        /// size at the start position (as a fixed-length 4-bytes size). The size does not include its own encoded
        /// length.</summary>
        /// <param name="start">The start position.</param>
        private void EndFixedLengthSize(Position start)
        {
            Debug.Assert(start.Offset >= 0);
            if (OldEncoding)
            {
                RewriteFixedLength11Size(Distance(start) - 4, start);
            }
            else
            {
                RewriteFixedLength20Size(Distance(start) - DefaultSizeLength, start);
            }
        }

        /// <summary>Expands the stream to make room for more data. If the bytes remaining in the stream are not enough
        /// to hold the given number of bytes allocate new byte array.</summary>
        /// <param name="n">The number of bytes to accommodate in the stream.</param>
        private void Expand(int n)
        {
            int remaining = _capacity - Size;
            if (n > remaining)
            {
                int size = Math.Max(DefaultSegmentSize, _currentSegment.Count * 2);
                size = Math.Max(n - remaining, size);
                byte[] buffer = new byte[size];
                _segmentList.Add(buffer);
                if (_segmentList.Count == 1)
                {
                    _currentSegment = buffer;
                }
                _capacity += buffer.Length;
            }
        }

        /// <summary>Computes the minimum number of bytes needed to write a variable-length size with the current
        /// encoding.</summary>
        /// <param name="size">The size.</param>
        /// <returns>The minimum number of bytes.</returns>
        private int GetSizeLength(int size)
        {
            if (OldEncoding)
            {
                return size < 255 ? 1 : 5;
            }
            else
            {
                ulong v = (ulong)size;
                v <<= 2;
                return v switch
                {
                    ulong b when b <= byte.MaxValue => 1,
                    ulong s when s <= ushort.MaxValue => 2,
                    ulong i when i <= uint.MaxValue => 4,
                    _ => 8
                };
            }
        }

        /// <summary>Writes a byte at a given position of the stream.</summary>
        /// <param name="v">The byte value to write.</param>
        /// <param name="pos">The position to write to.</param>
        private void RewriteByte(byte v, Position pos)
        {
            ArraySegment<byte> segment = _segmentList[pos.Segment];
            if (pos.Offset < segment.Count)
            {
                segment[pos.Offset] = v;
            }
            else
            {
                segment = _segmentList[pos.Segment + 1];
                segment[0] = v;
            }
        }

        /// <summary>Rewrites an encapsulation size on a fixed number of bytes at the given position of the stream.
        /// </summary>
        /// <param name="size">The number of bytes in the encapsulation, without taking into account the bytes for the
        /// size itself.</param>
        /// <param name="pos">The position to write to.</param>
        /// <param name="sizeLength">The number of bytes used to encode the size with the 2.0 encoding. Can be 1, 2 or
        /// 4.</param>
        private void RewriteEncapsulationSize(int size, Position pos, int sizeLength = DefaultSizeLength)
        {
            if (OldEncoding)
            {
                // With the 1.1 encoding, sizeLength is always 4 bytes and the encoded size includes this sizeLength.
                RewriteFixedLength11Size(size + 4, pos);
            }
            else
            {
                RewriteFixedLength20Size(size, pos, sizeLength);
            }
        }

        /// <summary>Writes a size on 4 bytes at the given position of the stream.</summary>
        /// <param name="size">The size to write.</param>
        /// <param name="pos">The position to write to.</param>
        private void RewriteFixedLength11Size(int size, Position pos)
        {
            Debug.Assert(pos.Segment < _segmentList.Count);
            Debug.Assert(pos.Offset <= Size - _segmentList.Take(pos.Segment).Sum(data => data.Count),
                $"offset: {pos.Offset} segment size: {Size - _segmentList.Take(pos.Segment).Sum(data => data.Count)}");

            Span<byte> data = stackalloc byte[4];
            MemoryMarshal.Write(data, ref size);
            RewriteByteSpan(data, pos);
        }

        /// <summary>Writes a size on a fixed number of bytes at the given position of the stream.</summary>
        /// <param name="size">The size to write.</param>
        /// <param name="pos">The position to write to.</param>
        /// <param name="sizeLength">The number of bytes used to encode the size. Can be 1, 2 or 4.</param>
        private void RewriteFixedLength20Size(int size, Position pos, int sizeLength = DefaultSizeLength)
        {
            Debug.Assert(pos.Segment < _segmentList.Count);
            Debug.Assert(pos.Offset <= Size - _segmentList.Take(pos.Segment).Sum(data => data.Count),
                $"offset: {pos.Offset} segment size: {Size - _segmentList.Take(pos.Segment).Sum(data => data.Count)}");

            Debug.Assert(sizeLength == 1 || sizeLength == 2 || sizeLength == 4);

            Span<byte> data = stackalloc byte[sizeLength];
            WriteFixedLength20Size(size, data);
            RewriteByteSpan(data, pos);
        }

        private void RewriteByteSpan(Span<byte> data, Position pos)
        {
            ArraySegment<byte> segment = _segmentList[pos.Segment];
            int remaining = Math.Min(data.Length, segment.Count - pos.Offset);
            if (remaining > 0)
            {
                data.Slice(0, remaining).CopyTo(segment.AsSpan(pos.Offset, remaining));
            }

            if (remaining < data.Length)
            {
                segment = _segmentList[pos.Segment + 1];
                data[remaining..].CopyTo(segment.AsSpan(0, data.Length - remaining));
            }
        }

        /// <summary>Returns the current position and writes a 4-bytes placeholder for a fixed-length size value. The
        /// position must be used to rewrite the size later.</summary>
        /// <returns>The position before writing the size.</returns>
        private Position StartFixedLengthSize()
        {
            Position pos = _tail;
            int sizeLength = OldEncoding ? 4 : DefaultSizeLength;
            WriteByteSpan(stackalloc byte[sizeLength]); // placeholder for future size
            return pos;
        }

        /// <summary>Writes a span of bytes. The stream capacity is expanded if required, the size and tail position are
        /// increased according to the span length.</summary>
        /// <param name="span">The data to write as a span of bytes.</param>
        private void WriteByteSpan(ReadOnlySpan<byte> span)
        {
            int length = span.Length;
            Expand(length);
            Size += length;
            int offset = _tail.Offset;
            int remaining = _currentSegment.Count - offset;
            if (remaining > 0)
            {
                int sz = Math.Min(length, remaining);
                if (length > remaining)
                {
                    span.Slice(0, remaining).CopyTo(_currentSegment.AsSpan(offset, sz));
                }
                else
                {
                    span.CopyTo(_currentSegment.AsSpan(offset, length));
                }
                _tail.Offset += sz;
                length -= sz;
            }

            if (length > 0)
            {
                _currentSegment = _segmentList[++_tail.Segment];
                if (remaining == 0)
                {
                    span.CopyTo(_currentSegment.AsSpan(0, length));
                }
                else
                {
                    span.Slice(remaining, length).CopyTo(_currentSegment.AsSpan(0, length));
                }
                _tail.Offset = length;
            }
        }

        /// <summary>Writes an encapsulation header.</summary>
        /// <param name="size">The size of the encapsulation, in bytes. This size does not include the length of the
        /// encoded size itself.</param>
        /// <param name="encoding">The encoding of the new encapsulation.</param>
        /// <param name="sizeLength">The number of bytes used to encode the size, used only with the 2.0 encoding. Can
        /// be 1, 2 or 4.</param>
        private void WriteEncapsulationHeader(int size, Encoding encoding, int sizeLength = DefaultSizeLength)
        {
            if (OldEncoding)
            {
                WriteInt(size + 4); // the size length is included in the encoded size with the 1.1 encoding.
            }
            else
            {
                Debug.Assert(sizeLength == 1 || sizeLength == 2 || sizeLength == 4);
                Span<byte> data = stackalloc byte[sizeLength];
                WriteFixedLength20Size(size, data);
                WriteByteSpan(data);
            }
            WriteByte(encoding.Major);
            WriteByte(encoding.Minor);
        }

        /// <summary>Writes a fixed-size numeric to the stream.</summary>
        /// <param name="v">The numeric value to write to the stream.</param>
        private void WriteFixedSizeNumeric<T>(T v) where T : struct
        {
            int elementSize = Unsafe.SizeOf<T>();
            Debug.Assert(elementSize > 1); // for size 1, we write the byte directly
            Span<byte> data = stackalloc byte[elementSize];
            MemoryMarshal.Write(data, ref v);
            WriteByteSpan(data);
        }

        /// <summary>Writes the header for a tagged parameter of data member.</summary>
        /// <param name="tag">The numeric tag associated with the parameter or data member.</param>
        /// <param name="format">The tag format.</param>
        private void WriteTaggedParamHeader(int tag, EncodingDefinitions.TagFormat format)
        {
            Debug.Assert(InEncapsulation);

            int v = (int)format;
            if (tag < 30)
            {
                v |= tag << 3;
                WriteByte((byte)v);
            }
            else
            {
                v |= 0x0F0; // tag = 30
                WriteByte((byte)v);
                WriteSize(tag);
            }
            if (_current != null)
            {
                _current.SliceFlags |= EncodingDefinitions.SliceFlags.HasTaggedMembers;
            }
        }
    }
}
